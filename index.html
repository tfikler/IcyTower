<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Platformer Game with Leaderboard</title>
  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; }
    #gameCanvas { background-color: #87CEEB; }
    #gameOverModal {
      display: none; /* Hidden by default */
      position: fixed; /* Stay in place */
      z-index: 1; /* Sit on top */
      left: 0;
      top: 0;
      width: 100%; /* Full width */
      height: 100%; /* Full height */
      overflow: auto; /* Enable scroll if needed */
      background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
      text-align: center;
    }
    #gameOverContent {
      background-color: #fefefe;
      margin: 15% auto; /* 15% from the top and centered */
      padding: 20px;
      border: 1px solid #888;
      width: 30%; /* Could be more or less, depending on screen size */
    }
    button {
      font-size: 20px;
      padding: 10px;
      margin-top: 20px;
    }
    ul {
      list-style-type: none;
      padding: 0;
    }
    li {
      margin: 5px 0;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="600" height="600"></canvas>
<div id="gameOverModal">
  <div id="gameOverContent">
    <h2>Game Over</h2>
    <p>Oops! You've lost.</p>
    <button onclick="restartGame()">Play Again</button>
    <h3>Leaderboard</h3>
    <ul id="leaderboard"></ul>
  </div>
</div>
<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const gameOverModal = document.getElementById('gameOverModal');
  const leaderboardEl = document.getElementById('leaderboard');

  let gameState = 'playing'; // 'playing' or 'gameOver'
  let lastUpdateTime = Date.now();
  const gravity = 0.5;
  const friction = 0.8;
  const baseJump = -10;
  let score = 0;
  let animationFrameId;


  let player = { x: canvas.width / 2, y: canvas.height - 150, width: 20, height: 20, speed: 5, velX: 0, velY: 0, jumping: false };
  let platforms = [];
  let platformCount = 10;
  for(let i = 0; i < platformCount; i++) {
    let hasEnemy = Math.random() < 0.05;
    let enemyType = hasEnemy ? Math.random() < 0.5 ? 1 : 2 : null;
    platforms.push({ x: Math.random() * (canvas.width - 50), y: canvas.height - (100 * i) - 50, width: 100, height: 20, enemy: hasEnemy ? { type: enemyType, x: 0, dir: 1 } : null, isScored: false, isTouchedAlready: false, timeOnPlatform: 0, label: i });
  }

  let keys = [];

  window.addEventListener('keydown', function(e) {
    if (gameState === 'playing') {
      keys[e.keyCode] = true;
      if (e.keyCode == 32 && !player.jumping) {
        player.jumping = true;
        player.velY = baseJump - Math.abs(player.velX);
      }
    }
  });
  window.addEventListener('keyup', function(e) {
    if (gameState === 'playing') {
      keys[e.keyCode] = false;
    }
  });

  function getTopScores() {
    const scoresStr = localStorage.getItem('topScores');
    return scoresStr ? JSON.parse(scoresStr) : [];
  }

  function updateTopScores(newScore) {
    const scores = getTopScores();
    scores.push(newScore);
    scores.sort((a, b) => b - a);
    scores.splice(10); // Keep only top 10 scores
    localStorage.setItem('topScores', JSON.stringify(scores));
  }

  function displayLeaderboard() {
    const scores = getTopScores();
    leaderboardEl.innerHTML = scores.map(score => `<li>${score}</li>`).join('');
  }

  function gameOver() {
    gameState = 'gameOver';
    updateTopScores(score);
    displayLeaderboard();
    gameOverModal.style.display = "block";
    cancelAnimationFrame(animationFrameId);
  }

  function restartGame() {
    document.location.reload();
  }

  function updateGame() {
    if (gameState !== 'playing') return;

    const now = Date.now();
    const deltaTime = (now - lastUpdateTime) / 1000;
    lastUpdateTime = now;
    // Check key inputs
    if (keys[39]) { // right arrow
      if (player.velX < player.speed) {
        player.velX++;
      }
    }
    if (keys[37]) { // left arrow
      if (player.velX > -player.speed) {
        player.velX--;
      }
    }

    player.velX *= friction;
    player.velY += gravity;

    player.x += player.velX;
    player.y += player.velY;

    // Screen scroll and enemy movement
    if (player.y < canvas.height / 4) {
      player.y += Math.abs(player.velY);
      platforms.forEach(platform => {
        platform.y += Math.abs(player.velY);
        platform.isScored = false; // Reset score for platforms
        if (platform.y > canvas.height) {
          platform.y = 0;
          platform.x = Math.random() * (canvas.width - platform.width);
          platform.label += platformCount; // Update label for recycling
          // Reset enemy for recycled platforms
          platform.enemy = Math.random() < 0.05 ? { type: Math.random() < 0.5 ? 1 : 2, x: 0, dir: 1 } : null;
        }
        // Move Type 2 enemies
        if (platform.enemy && platform.enemy.type === 2) {
          platform.enemy.x += platform.enemy.dir * 2; // Speed of enemy movement
          if (platform.enemy.x < 0 || platform.enemy.x > platform.width - 20) { // Enemy width assumed to be 20
            platform.enemy.dir *= -1; // Change direction
          }
        }
      });
    }

    // Collision with the canvas edges
    if (player.x >= canvas.width - player.width) {
      player.x = canvas.width - player.width;
    } else if (player.x <= 0) {
      player.x = 0;
    }

    if(player.y >= canvas.height - player.height){
      player.y = canvas.height - player.height;
      player.jumping = false;
      player.velY = 0;
    }

    let onPlatform = false;
    // Platform and enemy collision
    platforms.forEach(platform => {
      if (
              player.x < platform.x + platform.width &&
              player.x + player.width > platform.x &&
              player.y + player.height > platform.y &&
              player.y + player.height < platform.y + platform.height + 10 &&
              player.velY >= 0
      ) {
        player.jumping = false;
        player.velY = 0;
        player.y = platform.y - player.height;
        onPlatform = true;
        platform.isTouchedAlready = true;
        platform.timeOnPlatform += deltaTime;
        // Check for collision with enemy
        if (platform.enemy) {
          let enemyX = platform.x + (platform.enemy.type === 2 ? platform.enemy.x : 40); // Adjust for enemy position
          if (player.x < enemyX + 20 && player.x + player.width > enemyX) {
            // Reset player or handle death
            gameOver();
          }
        }
      } else {
        platform.timeOnPlatform = 0; // Reset if player is not on the platform
      }
    });

    // update score if player passed the platform
    platforms.map(platform => {
      if (platform.y > player.y + player.height && !platform.isTouchedAlready && !platform.isScored) {
        score++;
        platform.isScored = true;
      }
    });

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw player
    ctx.fillStyle = 'red';
    ctx.fillRect(player.x, player.y, player.width, player.height);

    // Draw platforms, labels, and enemies
    platforms.forEach(platform => {
      ctx.fillStyle = 'black';
      ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
      if (platform.label % 10 === 0) {
        ctx.fillStyle = 'white';
        ctx.font = '14px Arial';
        let text = platform.label.toString();
        let textWidth = ctx.measureText(text).width;
        let textX = platform.x + (platform.width - textWidth) / 2;
        let textY = platform.y + 20;
        ctx.fillText(text, textX, textY);
      }
      // Draw enemies
      if (platform.enemy) {
        ctx.fillStyle = platform.enemy.type === 1 ? 'purple' : 'orange';
        let enemyX = platform.x + (platform.enemy.type === 2 ? platform.enemy.x : 40); // Position for Type 2 enemy
        ctx.fillRect(enemyX, platform.y - 20, 20, 20); // Drawing enemy above the platform
      }
    });

    // Draw score
    ctx.fillStyle = 'black';
    ctx.font = '20px Arial';
    ctx.fillText("Score: " + score, 10, 30);

    requestAnimationFrame(updateGame);
  }
  animationFrameId = requestAnimationFrame(updateGame);
</script>
</body>
</html>
